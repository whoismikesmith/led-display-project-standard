# LED Display Project Standard
## Introduction

The LED Display Project Standard (LDPS) is a proposed JSON-based data format designed to standardize the way information about LED displays is shared and utilized across various tools and platforms within the video display pipeline. This standard aims to prevent miscommunication, increase efficiency, and enhance collaboration among video professionals by providing a common framework for describing LED screen configurations, pixel mappings, and related data.

## Schema Structure
The LDPS schema is flexible and customizable to accommodate a wide range of use cases. It includes properties for project names, screen configurations, panel specifications, sub-screen details, and output assignments

## Schema Customization
The JSON schema for the LED Display Project Standard is designed to be flexible to accommodate different use cases and applications within the video display pipeline. Users can adjust the elements in the "required" array based on their specific needs. This flexibility ensures that the schema can be broadly used across different tools and platforms, even if not all pieces of information are necessary for a particular application.

## Use Cases and Applications
The LED Display Project Standard can be utilized in various stages of the video display pipeline to enhance communication and efficiency among video professionals. Here are some potential applications:

### Pixel Mapping / Raster Mapping Tools
* **Generation**: The project data can be generated by specialized tools focused on pixel mapping and raster mapping. These tools can create detailed screen layouts, specifying the resolution, offsets, and configuration of each screen and sub-screen.
* **Export**: Once the mapping is complete, the data can be exported in the standardized JSON format.

### Media Servers
* **Import**: The exported JSON file can be imported into media servers such as Pixera, Disguise, and Resolume. The media servers can then utilize the detailed screen configuration to generate the required screens and mappings to fit the requirements of the project.
* **Configuration**: By importing the standardized project data, media servers can automatically configure mapping and output settings, ensuring that content is displayed correctly on each screen.

### LED Processing Software
* **Integration**: LED processing software like Brompton's Tessera Remote, Megapixel Helios, and Novastar's NovaLCT can import the JSON data to set up and manage LED screen projects. This integration helps efficiently map screens and maintain accuracy of dimensions, offsets, etc...

### Content Creation Tools
* **Design Guidelines**: Tools like Adobe After Effects, Adobe Premiere Pro, and GIMP can import the JSON data to provide content creators with accurate guidelines for the screens they are designing for.
* **Accurate Design**: By using the standardized data, content creators can ensure that their designs fit perfectly on the intended displays, taking into account resolution, aspect ratio, and screen layout.

## JSON Structure
### Project
* projectName (string): The name of the project.

### Screens
Each screen object contains the following properties:

* name (string): The name of the screen.
* mapWidth (integer): The width of the screen in panels.
* mapHeight (integer): The height of the screen in panels.
* panelWidth (integer): The width of a single panel in pixels.
* panelHeight (integer): The height of a single panel in pxiels.
* panelManufacturer (string): The manufacturer of the panel.
* panelName (string): The name of the panel.
* panelWidthInMm (integer): The width of the panel in millimeters.
* panelHeightInMm (integer): The height of the panel in millimeters.
* panelWeightInKg (number): The weight of the panel in kilograms.
* panelWattage (integer): The power consumption of the panel in watts.
* offsetX (integer): The horizontal offset of the screen in pixels.
* offsetY (integer): The vertical offset of the screen in pixels.
* assignedOutput (string): The ID of the output the screen is assigned to.
* panelyType (string, null): The type of panel.
* colors (array of strings): The colors used in the screen in hex color code format "#C95B54".
* opacity (array of numbers): The opacity levels for the screen from 0 (transparent) to 1 (fully opaque).
* rgbacolors (array of strings): The RGBA color values for the screen. To be used if transparent colors are required : rgba(255, 0, 0, 0.2).
* borders (object): Border properties for the screen and panels.
    * panel (object): Border properties for the panel.
        * color (string): The color of the panel border in hex color code format.
        * width (integer): The width of the panel border in pixels.
    * screen (object): Border properties for the screen.
        * color (string): The color of the screen border in hex color code format.
        * width (integer): The width of the screen border in pixels.
* dataFlow (integer): Data flow properties.
* powerFlow (integer): Power flow properties.
* coordinateStyle (integer): The style of coordinates used.
* dataColor (string): The color of the data in hex color code format.
* showCoordinates (boolean): Whether to show coordinates.
* showPanelBorder (boolean): Whether to show the panel border.
* showScreenBorder (boolean): Whether to show the screen border.
* showDataFlow (boolean): Whether to show data flow.
* showEveryOtherPixel (boolean): Whether to show every other pixel.
* showScalingCard (boolean): Whether to show the scaling card.
* showScreenName (boolean): Whether to show the screen name.
* showScreenSpecs (boolean): Whether to show the screen specifications.
* portSize (integer): The size of the port.
* portStart (integer): The starting point of the port.
* showLogo (boolean): Whether to show the logo.
* logoData (string, null): The data of the logo.
* logoOffsetX (integer): The horizontal offset of the logo.
* logoOffsetY (integer): The vertical offset of the logo.
* coloringMode (string): The coloring mode used.
* panelLibraryId (string, null): The ID of the panel in the library.
* halfRow (integer, null): The half row properties.
* rectangularPorts (boolean): Whether the ports are rectangular.
* portWidthLimit (integer): The width limit of the ports.
* portHeightLimit (integer): The height limit of the ports.
* processorType (string): The type of processor used.
* processorFrameRate (integer): The frame rate of the processor.
* processorBitDepth (integer): The bit depth of the processor.
* processorDatarate (integer): The data rate of the processor.
* subScreens (array): An array of subscreen objects.
    * id (string): The ID of the subscreen.
    * parentId (string): The ID of the parent screen.
    * direction (string): The direction of the split.
    * position (integer): The position of the split.
    * offsetX (integer): The horizontal offset of the subscreen.
    * offsetY (integer): The vertical offset of the subscreen.
    * assignedOutput (string): The ID of the output the subscreen is assigned to.
    * width (integer): The width of the subscreen.
    * height (integer): The height of the subscreen.
    * sourceX (integer): The horizontal source position.
    * sourceY (integer): The vertical source position.
    * latest (boolean): Whether the subscreen is the latest.
    * number (integer): The number of the subscreen.
* splitHistory (object): The history of splits for the screen.
* splitDirection (string, null): The direction of the split.
* splitPosition (integer, null): The position of the split.
* id (string): The ID of the screen.

### Outputs
Each output object contains the following properties:

* id (string): The ID of the output.
* width (integer): The width of the output in pixels.
* height (integer): The height of the output in pixels.
* color (string): The background color of the output in hex color code format.
* name (string): The name of the output.

### Active Screen and Output
* activeScreenId (string): The ID of the active screen.
* activeOutputId (string): The ID of the active output.

## Example Project
There is an example project in the **example-project** folder that shows an example project's output from the [blinkingthings.com](https://blinkingthings.com) pixel mapping tool to help illustrate an existing tool that can output project data in this format. 

## Usage
To validate a JSON object against this schema, you can use a JSON schema validator such as AJV in your Node.js projects, or any other JSON schema validation tool.

## Future Development
This JSON schema is currently a proposal and not yet officially supported by any industry-standard organization or specific software tools. The goal is to share this proposal with industry leaders, companies, and tool developers to encourage adoption and integration.

## Contributing
Contributions to improve and expand this standard are welcome. Please fork the repository and submit a pull request with your changes. Ensure your changes adhere to the existing style and structure of the standard.